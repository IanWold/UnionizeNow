using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;

namespace UnionizeNow;

[Generator(LanguageNames.CSharp)]
public class IncrementalUnionGenerator : IIncrementalGenerator {
    private record UnionRecord(INamedTypeSymbol Union, ImmutableArray<INamedTypeSymbol> Members) {
        public IEnumerable<string> UnionTypeParams { get; } = Union.TypeParameters.Select(t => t.Name);

        public string UnionName => $"{Union.Name}{(UnionTypeParams.Any() ? $"<{string.Join(", ", UnionTypeParams)}>" : "")}";
    }

    private record MemberParams(string TypeName, string Name);

    public void Initialize(IncrementalGeneratorInitializationContext context) {
        var targetInterface = context.CompilationProvider.Select((c, _) => c.GetTypeByMetadataName("UnionizeNow.IUnionizeNow"));

        var recordSymbols =
            context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (n, _) => n is RecordDeclarationSyntax,
                transform: static (c, _) => c.SemanticModel.GetDeclaredSymbol((RecordDeclarationSyntax)c.Node)
            )
            .Where(symbol => symbol is not null);

        var filtered =
            recordSymbols.Combine(targetInterface)
            .Select((pair, _) => {
                var (candidate, card) = pair;
                return IsUnionRecord(candidate, card, out var members)
                    ? new UnionRecord(candidate!, [.. members!])
                    : null;
            })
            .Where(s => s is not null);

        context.RegisterSourceOutput(filtered.Collect(), GenerateOutput);
    }

    private static bool IsPartial(INamedTypeSymbol symbol) =>
        symbol.DeclaringSyntaxReferences.Any(s => s.GetSyntax() is RecordDeclarationSyntax r && r.Modifiers.Any(m => m.IsKind(SyntaxKind.PartialKeyword)));

    private static bool IsUnionRecord(INamedTypeSymbol? union, INamedTypeSymbol? iface, out IEnumerable<INamedTypeSymbol>? members) {
        members = null;

        if (union is null
            || iface is null
            || !union.IsAbstract
            || !IsPartial(union)
            || !union.AllInterfaces.Any(i => SymbolEqualityComparer.Default.Equals(i, iface))
            || GetUnionMembers(union) is not IEnumerable<INamedTypeSymbol> unionMembers
            || !unionMembers.Any()
        ) {
            return false;
        }

        members = [.. unionMembers];
        return true;
    }

    public static IEnumerable<INamedTypeSymbol> GetUnionMembers(ITypeSymbol union) =>
        union.GetTypeMembers().Where(r => r.IsRecord && !r.IsAbstract && IsPartial(r));

    private static IEnumerable<MemberParams> GetCtorParams(INamedTypeSymbol symbol) =>
        symbol.InstanceConstructors.FirstOrDefault(c => c.MethodKind == MethodKind.Constructor && c.DeclaringSyntaxReferences.Any(s => s.GetSyntax() is RecordDeclarationSyntax)) is IMethodSymbol primaryCtor
        ? primaryCtor.Parameters.Select(p => new MemberParams(p.Type.ToDisplayString(), p.Name))
        : [];

    private static void GenerateOutput(SourceProductionContext context, ImmutableArray<UnionRecord?> types) {
        var output = new StringBuilder();

        output.AppendLine("// <auto-generated />");
        output.AppendLine("using System;");
        output.AppendLine();

        var typeGroups =
            types
            .Where(t => t is not null)
            .GroupBy(t => t!.Union.ContainingNamespace!.ToDisplayString());
        
        foreach (var unions in typeGroups) {
            output.AppendLine($"namespace {unions.Key}");
            output.AppendLine("{");

            var resultRecords = new Dictionary<string, IEnumerable<MemberParams>>();

            foreach (var union in unions) {
                output.AppendLine($"    public abstract partial record {union!.UnionName} {{");

                foreach (var member in union!.Members) {
                    var memberParams = GetCtorParams(member);
                    var commonTypeParams = union!.UnionTypeParams.Intersect(memberParams.Select(p => p.TypeName));
                    var resultRecord = $"{member.Name}{(commonTypeParams.Any() ? $"<{string.Join(", ", commonTypeParams)}>" : string.Empty)}";

                    output.AppendLine($"        public partial record {member.Name} : {union!.UnionName}, I{resultRecord};");
                    output.AppendLine($"        public static implicit operator {union!.UnionName}({unions.Key}.{resultRecord} r) =>");
                    output.AppendLine($"            new {union!.UnionName}.{member.Name}({string.Join(", ", memberParams.Select(p => $"r.{p.Name}"))});");

                    resultRecords[resultRecord] = memberParams;
                }

                output.AppendLine("    }");
                output.AppendLine();
            }

            foreach (var resultRecord in resultRecords.Distinct()) {
                var ctorParams = string.Join(", ", resultRecord.Value.Select(m => $"{m.TypeName} {m.Name}"));
                output.AppendLine($"    public readonly record struct {resultRecord.Key}({ctorParams}) : I{resultRecord.Key};");
                output.AppendLine($"    public interface I{resultRecord.Key} {{");

                foreach (var p in resultRecord.Value) {
                    output.AppendLine($"        {p.TypeName} {p.Name} {{ get; }}");
                }

                output.AppendLine("    }");
                output.AppendLine();
            }

            output.AppendLine("}");
            output.AppendLine();
        }

        context.AddSource("UnionRoster.g.cs", output.ToString());
    }
}
